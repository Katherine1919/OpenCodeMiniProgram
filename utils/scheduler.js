function timeToMinutes(time) {
  if (!time || typeof time !== 'string') return 0;
  const parts = time.split(':');
  if (parts.length !== 2) return 0;
  const [h, m] = parts.map(Number);
  if (isNaN(h) || isNaN(m)) return 0;
  return h * 60 + m;
}

function minutesToTime(mins) {
  const h = Math.floor(mins / 60);
  const m = mins % 60;
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

function shouldShowFixed(task, date) {
  if (!task.isFixed) return false;
  if (task.status === 'done') return false;
  
  if (!task.repeatRule || task.repeatRule === 'daily') {
    return true;
  }
  
  if (!task.createdAt) return true;
  
  const taskDate = new Date(task.createdAt);
  const targetDate = new Date(date);
  
  if (isNaN(taskDate.getTime()) || isNaN(targetDate.getTime())) {
    return true;
  }
  
  if (task.repeatRule === 'weekly') {
    return taskDate.getDay() === targetDate.getDay();
  } else if (task.repeatRule === 'biweekly') {
    const daysDiff = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
    const weeksDiff = Math.floor(daysDiff / 7);
    return taskDate.getDay() === targetDate.getDay() && weeksDiff % 2 === 0;
  } else if (task.repeatRule === 'monthly') {
    return taskDate.getDate() === targetDate.getDate();
  }
  
  return true;
}

function generateSchedule(tasks, templates, date) {
  const items = [];
  const usedSlots = [];
  const conflictFixedTaskIds = [];
  const outOfTemplateFixedTaskIds = [];
  const invalidFixedTaskIds = [];
  
  templates.sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
  
  const fixedTasks = tasks.filter(t => {
    if (!t.isFixed) return false;
    if (t.status === 'done') return false;
    return shouldShowFixed(t, date);
  });
  
  const normalTasks = tasks.filter(t => 
    !t.isFixed &&
    (t.status === 'todo' || t.status === 'scheduled' || t.status === 'overflow')
  );
  
  fixedTasks.forEach(task => {
    const invalid = !task.startTime || !task.minutes || task.minutes <= 0;
    
    if (invalid) {
      invalidFixedTaskIds.push(task.id);
      items.push({
        id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        taskId: task.id,
        kind: 'task',
        title: task.title,
        start: task.startTime || '00:00',
        end: task.endTime || '00:00',
        minutes: task.minutes || 0,
        status: 'scheduled',
        isAutoGenerated: true,
        isFixed: true,
        invalid: true
      });
      return;
    }
    
    let endTime = task.endTime;
    if (!endTime && task.startTime && task.minutes) {
      const startMins = timeToMinutes(task.startTime);
      const endMins = startMins + task.minutes;
      if (endMins >= 1440) {
        invalidFixedTaskIds.push(task.id);
        items.push({
          id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
          taskId: task.id,
          kind: 'task',
          title: task.title,
          start: task.startTime,
          end: '23:59',
          minutes: task.minutes,
          status: 'scheduled',
          isAutoGenerated: true,
          isFixed: true,
          invalid: true
        });
        return;
      }
      endTime = minutesToTime(endMins);
    }
    
    const start = timeToMinutes(task.startTime);
    const end = timeToMinutes(endTime);
    
    if (end <= start) {
      invalidFixedTaskIds.push(task.id);
      items.push({
        id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
        taskId: task.id,
        kind: 'task',
        title: task.title,
        start: task.startTime,
        end: endTime,
        minutes: task.minutes,
        status: 'scheduled',
        isAutoGenerated: true,
        isFixed: true,
        invalid: true
      });
      return;
    }
    
    const validTemplate = templates.find(tmpl => 
      timeToMinutes(tmpl.start) <= start && 
      timeToMinutes(tmpl.end) >= end
    );
    
    if (!validTemplate) {
      outOfTemplateFixedTaskIds.push(task.id);
    }
    
    const hasConflict = usedSlots.some(slot => 
      !(end <= slot.start || start >= slot.end)
    );
    
    if (hasConflict) {
      conflictFixedTaskIds.push(task.id);
    }
    
    items.push({
      id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      taskId: task.id,
      kind: 'task',
      title: task.title,
      start: task.startTime,
      end: endTime,
      minutes: end - start,
      status: 'scheduled',
      isAutoGenerated: true,
      isFixed: true,
      conflict: hasConflict,
      outOfTemplate: !validTemplate
    });
    
    usedSlots.push({ start, end });
  });
  
  normalTasks.sort((a, b) => {
    const priorityMap = {high: 3, mid: 2, medium: 2, low: 1};
    if (a.priority !== b.priority) {
      return (priorityMap[b.priority] || 1) - (priorityMap[a.priority] || 1);
    }
    if (a.ddl && b.ddl) {
      return new Date(a.ddl) - new Date(b.ddl);
    }
    if (a.ddl) return -1;
    if (b.ddl) return 1;
    return new Date(a.createdAt || 0) - new Date(b.createdAt || 0);
  });
  
  normalTasks.forEach(task => {
    let placed = false;
    
    for (const tmpl of templates) {
      if (placed) break;
      
      const tmplStart = timeToMinutes(tmpl.start);
      const tmplEnd = timeToMinutes(tmpl.end);
      
      const slotsInTemplate = usedSlots.filter(s => 
        s.start < tmplEnd && s.end > tmplStart
      ).sort((a, b) => a.start - b.start);
      
      let cursor = tmplStart;
      
      for (let i = 0; i <= slotsInTemplate.length; i++) {
        const nextSlotStart = slotsInTemplate[i]?.start || tmplEnd;
        const gap = nextSlotStart - cursor;
        
        if (gap >= task.minutes) {
          items.push({
            id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            taskId: task.id,
            kind: 'task',
            title: task.title,
            start: minutesToTime(cursor),
            end: minutesToTime(cursor + task.minutes),
            minutes: task.minutes,
            status: 'scheduled',
            isAutoGenerated: true,
            isFixed: false
          });
          
          usedSlots.push({ start: cursor, end: cursor + task.minutes });
          usedSlots.sort((a, b) => a.start - b.start);
          placed = true;
          break;
        }
        
        if (slotsInTemplate[i]) {
          cursor = slotsInTemplate[i].end;
        }
      }
    }
  });
  
  items.sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
  
  const placedTaskIds = items.map(it => it.taskId);
  const overflowTasks = normalTasks.filter(t => !placedTaskIds.includes(t.id));
  
  return { 
    scheduleItems: items, 
    overflowTaskIds: overflowTasks.map(t => t.id),
    conflictFixedTaskIds,
    outOfTemplateFixedTaskIds,
    invalidFixedTaskIds
  };
}

module.exports = {
  generateSchedule,
  timeToMinutes,
  minutesToTime,
  shouldShowFixed
};
