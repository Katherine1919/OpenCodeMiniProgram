function timeToMinutes(time) {
  if (!time || typeof time !== 'string') return 0;
  const parts = time.split(':');
  if (parts.length !== 2) return 0;
  const [h, m] = parts.map(Number);
  if (isNaN(h) || isNaN(m)) return 0;
  return h * 60 + m;
}

function minutesToTime(mins) {
  const h = Math.floor(mins / 60);
  const m = mins % 60;
  return `${String(h).padStart(2, '0')}:${String(m).padStart(2, '0')}`;
}

function shouldShowFixed(task, date) {
  if (!task.isFixed) return false;
  if (task.status === 'done') return false;
  
  if (!task.repeatRule || task.repeatRule === 'daily') {
    return true;
  }
  
  if (!task.createdAt) return true;
  
  const taskDate = new Date(task.createdAt);
  const targetDate = new Date(date);
  
  if (isNaN(taskDate.getTime()) || isNaN(targetDate.getTime())) {
    return true;
  }
  
  if (task.repeatRule === 'weekly') {
    return taskDate.getDay() === targetDate.getDay();
  } else if (task.repeatRule === 'biweekly') {
    const daysDiff = Math.floor((targetDate - taskDate) / (1000 * 60 * 60 * 24));
    const weeksDiff = Math.floor(daysDiff / 7);
    return taskDate.getDay() === targetDate.getDay() && weeksDiff % 2 === 0;
  } else if (task.repeatRule === 'monthly') {
    return taskDate.getDate() === targetDate.getDate();
  }
  
  return true;
}

function generateSchedule(tasks, templates, date) {
  const items = [];
  const usedSlots = [];
  const conflictFixedTaskIds = [];
  
  templates.sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
  
  const fixedTasks = tasks.filter(t => {
    if (!t.isFixed) return false;
    if (t.status === 'done') return false;
    return shouldShowFixed(t, date);
  });
  
  const normalTasks = tasks.filter(t => 
    !t.isFixed &&
    (t.status === 'todo' || t.status === 'scheduled' || t.status === 'overflow')
  );
  
  fixedTasks.forEach(task => {
    if (!task.startTime || !task.endTime) return;
    
    const start = timeToMinutes(task.startTime);
    const end = timeToMinutes(task.endTime);
    
    if (end <= start || end > 1440) return;
    
    const hasConflict = usedSlots.some(slot => 
      !(end <= slot.start || start >= slot.end)
    );
    
    if (hasConflict) {
      conflictFixedTaskIds.push(task.id);
    }
    
    items.push({
      id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
      taskId: task.id,
      kind: 'task',
      title: task.title,
      start: task.startTime,
      end: task.endTime,
      minutes: end - start,
      status: 'scheduled',
      isAutoGenerated: true,
      isFixed: true,
      conflict: hasConflict
    });
    
    usedSlots.push({ start, end });
  });
  
  normalTasks.sort((a, b) => {
    const priorityMap = {high: 3, mid: 2, medium: 2, low: 1};
    if (a.priority !== b.priority) {
      return (priorityMap[b.priority] || 1) - (priorityMap[a.priority] || 1);
    }
    if (a.ddl && b.ddl) {
      return new Date(a.ddl) - new Date(b.ddl);
    }
    if (a.ddl) return -1;
    if (b.ddl) return 1;
    return new Date(a.createdAt || 0) - new Date(b.createdAt || 0);
  });
  
  normalTasks.forEach(task => {
    let placed = false;
    
    for (const tmpl of templates) {
      if (placed) break;
      
      const tmplStart = timeToMinutes(tmpl.start);
      const tmplEnd = timeToMinutes(tmpl.end);
      
      const slotsInTemplate = usedSlots.filter(s => 
        s.start < tmplEnd && s.end > tmplStart
      ).sort((a, b) => a.start - b.start);
      
      let cursor = tmplStart;
      
      for (let i = 0; i <= slotsInTemplate.length; i++) {
        const nextSlotStart = slotsInTemplate[i]?.start || tmplEnd;
        const gap = nextSlotStart - cursor;
        
        if (gap >= task.minutes) {
          items.push({
            id: `sched_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            taskId: task.id,
            kind: 'task',
            title: task.title,
            start: minutesToTime(cursor),
            end: minutesToTime(cursor + task.minutes),
            minutes: task.minutes,
            status: 'scheduled',
            isAutoGenerated: true,
            isFixed: false
          });
          
          usedSlots.push({ start: cursor, end: cursor + task.minutes });
          usedSlots.sort((a, b) => a.start - b.start);
          placed = true;
          break;
        }
        
        if (slotsInTemplate[i]) {
          cursor = slotsInTemplate[i].end;
        }
      }
    }
  });
  
  items.sort((a, b) => timeToMinutes(a.start) - timeToMinutes(b.start));
  
  const placedTaskIds = items.map(it => it.taskId);
  const overflowTasks = normalTasks.filter(t => !placedTaskIds.includes(t.id));
  
  return { 
    scheduleItems: items, 
    conflictFixedTaskIds,
    overflowTaskIds: overflowTasks.map(t => t.id)
  };
}

module.exports = {
  generateSchedule,
  timeToMinutes,
  minutesToTime,
  shouldShowFixed
};
